C++编码规范
信1703 姚鋆 20173417
目录
1.排版风格	1
2. 可理解性	1
2.1 注释	1
2.2 命名	2
2.3 可维护性	2
2.4. 程序正确性、效率	3
2.5  接口	4
2.6 代码可测性	4
2.7 代码编译	5
1.排版风格
1、程序块采用缩进风格编写，缩进为4个空格位。排版不混合使用空格和TAB键。
2、在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格;进行非对等操作时，如果是关系密切的立即操作符(如->)，后不应加空格。由于留空格所产生的清晰性是相对的，所以，在已经非常清晰的语句中没有必要再留空格，如最内层的括号内侧(即左括号后面和右括号前面)不要加空格，因为在C/C++语言中括号已经是最清晰的标志了。另外，在长语句中，如果需要加的空格非常多，那么应该保持整体清晰，而在局部不加空格。最后，即使留空格，也不要连续留两个以上空格(为了保证缩进和排比留空除外)。
3、函数体的开始，类的定义，结构的定义，if、for、do、while、switch及case语句中的程序都应采用缩进方式。
4、功能相对独立的程序块之间或for、if、do、while、switch等语句前后应加一空行。
5、if、while、for、case、default、do等语句自占一行。
6、若语句较长(多于80字符)，可分成多行写，划分出的新行要进行适应的缩进，使排版整齐，语句可读。
7、一行最多写一条语句。
8、对结构成员赋值，等号对齐。
9、#define的各个字段对齐
10、不同类型的操作符混合使用时，使用括号给出优先级。
2. 可理解性
　　2.1 注释
　　 注释的原则是有助于对程序的阅读理解，注释不宜太多也不能太少，太少不利于代码理解，太多则会对阅读产生干扰，因此只在必要的地方才加注释，而且注释要准确、易懂、尽可能简洁。注释量一般控制在30%到50%之间。
1、程序在必要的地方必须有注释，注释要准确、易懂、简洁。
2、注释应与其描述的代码相近，对代码的注释应放在其上方或右方(对单条语句的注释)相邻位置，不可放在下面，如放于上方则需与其上面的代码用空行隔开。
3、对于所有的常量，变量，数据结构声明(包括数组、结构、类、枚举等)，如果其命名不是充分自注释的，在声明时都必须加以注释，说明其含义。
4、头文件、源文件的头部，应进行注释。注释必须列出:文件名、作者、目的、功能、修改日志等。
5、函数头部应进行注释，列出:函数的目的、功能、输入参数、输出参数、修改日志等。
6、仔细定义并明确公共变量的含义、作用、取值范围及使用方法。
在对变量声明的同时，应对其含义、作用、取值范围及使用方法进行注释说明，同时若有必要还应说明与其它变量的关系。明确公共变量与操作此公共变量的函数或过程的关系，如访问、修改及创建等。
7、对指针进行充分的注释说明，对其作用、含义、使用范围、注意事项等说明清楚。在对指针变量、特别是比较复杂的指针变量声明时，应对其含义、作用及使用范围进行注释说明，如有必要，还应说明其使用方法、注意事项等。
8、对重要代码段的功能、意图进行注释，提供有用的、额外的信息。并在该代码段的结束处加一行注释表示该段代码结束。
9、在switch语句中，对没有break语句的case分支加上注释说明。
10、维护代码时，要更新相应的注释，删除不再有用的注释。保持代码、注释的一致性，避免产生误解。
　2.2 命名
1、标识符缩写
  关于缩写的准则:
  1) 缩写应该保持一致性。如Channel不要有时缩写成Chan，有时缩写成Ch。Length有时缩写成Len，有时缩写成len。
  2) 在源代码头部加入注解来说明协议相关的、非通用缩写。
  3) 标识符的长度不超过32个字符。
2、变量命名约定
[作用范围域前缀] + [前缀] + 基本类型 + 变量名
3、宏和常量的命名
宏和常量的命名规则:单词的字母全部大写，各单词之间用下划线隔开。
4、结构和结构成员的命名，结构名各单词的字母均为大写，单词间用下划线连接。可用或不用typedef，但是要保持一致，不能有的结构用typedef，有的又不用。
5、枚举和枚举成员的命名，枚举名各单词的字母均为大写，单词间用下划线隔开。枚举成员的命名规则:单词的字母全部大写，各单词之间用下划线隔开;要求各成员的第一个单词相同。
6、函数的命名
单词首字母为大写，其余均为小写，单词之间不用下划线。
　2.3 可维护性
1、在逻辑表达式中使用明确的逻辑判断。
2、预编译条件不应分离一完整的语句。
3、在宏定义中合并预编译条件。
4、使用宏定义表达式时，要使用完备的括号。
5、宏所定义的多条表达式应放在大括号内。
6、宏定义不能隐藏重要的细节，避免有return，break等导致程序流程转向的语句。
7、使用宏时，不允许参数发生变化。
9、结构中元素布局合理，一行只定义一个元素。
10、枚举值从小到大顺序定义。
11、不允许使用复杂的操作符组合等。
12、函数和过程中关系较为紧密的代码尽可能相邻。
13、每个函数的源程序行数原则上应该少于200行。
14、语句嵌套层次不得超过5层。
15、用sizeof来确定结构、联合或变量占用的空间。
16、避免相同的代码段在多个地方出现。
17、每个函数完成单一的功能，不设计多用途面面俱到的函数。
18、使用强制类型转换。
19、避免使用 goto 语句。
20、功能相近的一组常量最好使用枚举来定义。
2.4. 程序正确性、效率
1、严禁使用未经初始化的变量。引用未经初始化的变量可能会产生不可预知的后果，特别是引用未经初始化的指针经常会导致系统崩溃，需特别注意。声明变量的同时初始化，除了能防止引用未经初始化的变量外，还可能生成更高效的机器代码。
2、定义公共指针的同时对其初始化。这样便于指针的合法性检查，防止应用未经初始化的指针。建议对局部指针也在定义的同时初始化，形成习惯。
3、较大的局部变量(2K以上)应声明成静态类型(static)，避免占用太多的堆栈空间。避免发生堆栈溢出，出现不可预知的软件故障。
4、防止内存操作越界。
5、减少没必要的指针使用，特别是较复杂的指针，如指针的指针、数组的指针，指针的数组，函数的指针等。
6、防止引用已经释放的内存空间。在实际编程过程中，稍不留心就会出现在一个模块中释放了某个内存块(如指针)，而另一模块在随后的某个时刻又使用了它。要防止这种情况发生。
7、程序中分配的内存、申请的文件句柄，在不用时应及时释放或关闭。分配的内存不释放以及文件句柄不关闭，是较常见的错误，而且稍不注意就有可能发生。这类错误往往会引起很严重后果，且难以定位。
8、注意变量的有效取值范围，防止表达式出现上溢或下溢。
9、防止精度损失。
10、防止操易混淆的作符拼写错误。
11、使用无符号类型定义位域变量。
12、switch语句的程序块中必须有default语句。
13、当声明用于分布式环境或不同CPU间通信环境的数据结构时，必须考虑机器的字节顺序，使用的位域也要有充分的考虑。
14、编写可重入函数时，应注意局部变量的使用(如编写C/C++语言的可重入函数时，应使用auto即缺省态局部变量或寄存器变量)。
15、编写可重入函数时，若使用全局变量，则应通过关中断、信号量(即P、V操作)等手段对其加以保护。
16、结构中的位域应尽可能相邻。
17、避免函数中不必要语句，防止程序中的垃圾代码，预留代码应以注释的方式出现。程序中的垃圾代码不仅占用额外的空间，而且还常常影响程序的功能与性能，很可能给程序的测试、维护等造成不必要的麻烦。
18、通过对系统数据结构的划分与组织的改进，以及对程序算法的优化来提高空间效率。
19、循环体内工作量最小化。
20、在多重循环中，应将最忙的循环放在最内层。
21、避免循环体内含判断语句，将与循环变量无关的判断语句移到循环体外。目的是减少判断次数。循环体中的判断语句是否可以移到循环体外，要视程序的具体情况而言，一般情况，与循环变量无关的判断语句可以移到循环体外，而有关的则不可以。
22、尽量用乘法或其它方法代替除法，特别是浮点运算中的除法，在时间效率要求不是特别严格时，要优先保证程序的可读性。
23、系统输入(如用户输入)、系统输出(如信息包输出)、系统资源操作(如内存分配、文件及目录操作)、网络操作(如通信、调用等)、任务之间的操作(如通信、调用等)时必须进行错误、超时或者异常处理。
2.5  接口
1、头文件应采用 #ifndef / #define / #endif 的方式来防止多次被嵌入。
2、去掉没有必要的公共变量，编程时应尽量少用公共变量。
3、当向公共变量传递数据时，要防止越界现象发生。
4、返回值为指针的函数，不可将局部变量的地址作为返回值。
5、尽量不设计多参数函数，将不使用的参数从接口中去掉，降低接口复杂度。减少函数间接口的复杂度。
6、对所调用函数的返回码要仔细、全面地处理。
7、显示地给出函数的返回值类型。无返回值函数定义为void。
8、声明函数原型时给出参数名称和类型，并且与实现此函数时的参数名称、类型保持一致，无参数的函数，用void声明。
9、检查接口函数所有输入参数的有效性。
10、检查函数的所有非参数输入，如数据文件、公共变量等。
2.6 代码可测性
1、模块编写应该有完善的测试方面的考虑。
2、源代码中应该设计了代码测试的内容，如打印宏开关、变量值、函数名称、函数值等。
3、在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。
4、在同一项目组或产品组内，调测打印出的信息串的格式要有统一的形式。信息串中至少要有所在模块名(或源文件名)及行号。
5、使用断言来发现软件问题，提高代码可测性。
6、用断言来检查程序正常运行时不应发生但在调测时有可能发生的非法情况。
7、不能用断言代替错误处理来检查最终产品肯定会出现且必须处理的错误情况。
8、用断言确认函数的参数。
9、用断言保证没有定义的特性或功能不被使用。
10、用断言对程序开发环境(OS/Compiler/Hardware)的假设进行检查。
11、正式软件产品中应把断言及其它调测代码去掉(即把有关的调测开关关掉)。
12、用调测开关来切换软件的DEBUG版和正式版，而不要同时存在正式版本和DEBUG版本的不同源文件，以减少维护的难度。
13、在软件系统中设置与取消有关测试手段，不能对软件实现的功能等产生影响。即有测试代码的软件和关掉测试代码的软件，在功能行为上应一致。
14、发现错误应该立即修改，并且若有必要记录下来。
15、开发人员应坚持对代码进行彻底的测试(单元测试)，而不依靠他人或测试组来发现问题。
16、清理、整理或优化后的代码要经过审查及测试。
17、代码版本升级要经过严格测试。
2.7 代码编译
1、打开编译器的所有告警开关对程序进行编译。防止隐藏可能是错误的告警。
2、在同一项目组或产品组中，要统一编译开关选项。
3、某些语句经编译后产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。

JAVA编码规范
信1703 姚鋆 20173417

目录
JAVA编码规范	1
源文件基础	1
1.1 文件名	1
1.2 文件编码：UTF-8	2
1.3 特殊字符	2
源文件结构	2
2.1 许可证或版权信息	3
2.2 package语句	3
2.3 import语句	3
2.4 类声明	3
格式	4
3.1 大括号	4
3.2 块缩进：2个空格	4
3.3 一行一个语句	4
3.4 列限制：80或100	4
3.5 自动换行	5
3.6 空白	5
3.7 用小括号来限定组：推荐	6
3.8 具体结构	7
命名约定	8
4.1 对所有标识符都通用的规则	8
4.2 标识符类型的规则	8
4.3 驼峰式命名法(CamelCase)	9
编程实践	10
5.1 @Override：能用则用	10
5.2 捕获的异常：不能忽视	10
5.3 静态成员：使用类进行调用	10
5.4 Finalizers: 禁用	10
Javadoc	10
6.1 格式	10
6.2 摘要片段	11
6.3 哪里需要使用Javadoc	11

源文件基础
1.1 文件名
源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为.java。
1.2 文件编码：UTF-8
源文件编码格式为UTF-8。
1.3 特殊字符
1.3.1 空白字符
除了行结束符序列，ASCII水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：
1.所有其它字符串中的空白字符都要进行转义。
2.制表符不用于缩进。
1.3.2 特殊转义序列
对于具有特殊转义序列的任何字符(\b, \t, \n, \f, \r, \“, \‘及\)，我们使用它的转义序列，而不是相应的八进制(比如\012)或Unicode(比如\u000a)转义。
1.3.3 非ASCII字符
对于剩余的非ASCII字符，是使用实际的Unicode字符(比如∞)，还是使用等价的Unicode转义符(比如\u221e)，取决于哪个能让代码更易于阅读和理解。
Tip: 在使用Unicode转义符或是一些实际的Unicode字符时，建议做些注释给出解释，这有助于别人阅读和理解。
Tip: 永远不要由于害怕某些程序可能无法正确处理非ASCII字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，它自然无法正确运行， 你就会去fix这些问题的了。(言下之意就是大胆去用非ASCII字符，如果真的有需要的话)
源文件结构
一个源文件包含(按顺序地)：
1.许可证或版权信息(如有需要)
2.package语句
3.import语句
4.一个顶级类(只有一个)
以上每个部分之间用一个空行隔开。
2.1 许可证或版权信息
如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。
2.2 package语句
package语句不换行，列限制(4.4节)并不适用于package语句。(即package语句写在一行里)
2.3 import语句
2.3.1 import
不要使用通配符即，不要出现类似这样的import语句：import java.util.*;
2.3.2 不要换行
import语句不换行，列限制(4.4节)并不适用于import语句。(每个import语句独立成行)
2.3.3 顺序和间距
import语句可分为以下几组，按照这个顺序，每组由一个空行分隔：
1.所有的静态导入独立成组
2.com.google imports(仅当这个源文件是在com.google包下)
3.第三方的包。每个顶级包为一组，字典序。例如：android, com, junit, org, sun
4.java imports
5.javax imports组内不空行，按字典序排列。
2.4 类声明
2.4.1 只有一个顶级类声明
每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。
例外：package-info.java，该文件中可没有package-info类。
2.4.2 类成员顺序
类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。 最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。
2.4.2.1 重载：永不分离
当一个类有多个构造函数，或是多个同名方法，这些函数/方法应该按顺序出现在一起，中间不要放进其它函数/方法。
格式
术语说明：块状结构(block-like construct)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。
3.1 大括号
3.1.1 使用大括号(即使是可选的)
大括号与if, else, for, do, while语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。
3.1.2 非空块：K & R 风格
对于非空块和块状结构，大括号遵循Kernighan和Ritchie风格 (Egyptian brackets):
左大括号前不换行
左大括号后换行
右大括号前换行
如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。
3.1.3 空块：可以用简洁版本
一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分(if/else 或 try/catch/finally) ，即使大括号内没内容，右大括号也要换行。
3.2 块缩进：2个空格
每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。(见4.1.2节中的代码示例)
3.3 一行一个语句
每个语句后要换行。
3.4 列限制：80或100
一个项目可以选择一行80个字符或100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。
例外：
1.不可能满足列限制的行(例如，Javadoc中的一个长URL，或是一个长的JSNI方法参考)。
2.package和import语句(见3.2节和3.3节)。
3.注释中那些可能被剪切并粘贴到shell中的命令行。
3.5 自动换行
术语说明：一般情况下，一行长代码为了避免超出列限制(80或100个字符)而被分为多行，我们称之为自动换行(line-wrapping)。我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。
Tip: 提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)
3.5.1 从哪里断开
自动换行的基本准则是：更倾向于在更高的语法级别处断开。
1.如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：点分隔符(.)，类型界限中的&（<T extends Foo & Bar>)，catch块中的管道符号(catch (FooException | BarException e)
2.如果在赋值运算符处断开，通常的做法是在该符号后断开(比如=，它与前面的内容留在同一行)。这条规则也适用于foreach语句中的分号。
3.方法名或构造函数名与左括号留在同一行。
4.逗号(,)与其前面的内容留在同一行。
3.5.2 自动换行时缩进至少+4个空格
自动换行时，第一行后的每一行至少比第一行多缩进4个空格(注意：制表符不用于缩进。见2.3.1节)。当存在连续自动换行时，缩进可能会多缩进不只4个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。
3.6 空白
3.6.1 垂直空白
以下情况需要使用一个空行：
1.类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。
例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。
2.在函数体内，语句的逻辑分组间使用空行。
3.类内的第一个成员前或最后一个成员后的空行是可选的(既不鼓励也不反对这样做，视个人喜好而定)。
4.要满足本文档中其他节的空行要求(比如3.3节：import语句)
多个连续的空行是允许的，但没有必要这样做(我们也不鼓励这样做)。
3.6.2 水平空白
除了语言需求和其它规则，并且除了文字，注释和Javadoc用到单个空格，单个ASCII空格也出现在以下几个地方：
1.分隔任何保留字与紧随其后的左括号(()(如if, for catch等)。
2.分隔任何保留字与其前面的右大括号(})(如else, catch)。
3.在任何左大括号前({)，两个例外：
@SomeAnnotation({a, b})(不使用空格)。
String[][] x = foo;(大括号间没有空格，见下面的Note)。
4.在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：
类型界限中的&(<T extends Foo & Bar>)。
catch块中的管道符号(catch (FooException | BarException e)。
foreach语句中的分号。
5.在, : ;及右括号())后
6.如果在一条语句后做注释，则双斜杠(//)两边都要空格。这里可以允许多个空格，但没有必要。
7.类型和变量之间：List list。
8.数组初始化中，大括号内的空格是可选的，即new int[] {5, 6}和new int[] { 5, 6 }都是可以的。
Note：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。
3.6.3 水平对齐：不做要求
术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。
Tip：对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。
3.7 用小括号来限定组：推荐
除非作者和reviewer都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。
3.8 具体结构
3.8.1 枚举类
枚举常量间用逗号隔开，换行可选。没有方法和文档的枚举类可写成数组初始化的格式：由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。
3.8.2 变量声明
3.8.2.1 每次只声明一个变量
不要使用组合声明，比如int a, b;。
3.8.2.2 需要时才声明，并尽快进行初始化
不要在一个代码块的开头把局部变量一次性都声明了(这是c语言的做法)，而是在第一次需要使用它时才声明。 局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。
3.8.3 数组
3.8.3.1 数组初始化
可写成块状结构数组初始化可以写成块状结构
3.8.3.2 非C风格的数组声明
中括号是类型的一部分：String[] args， 而非String args[]。
3.8.4 switch语句
术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个switch标签(case FOO:或default:)，后面跟着一条或多条语句。
3.8.4.1 缩进
与其它块状结构一致，switch块中的内容缩进为2个空格。每个switch标签后新起一行，再缩进2个空格，写下一条或多条语句。
3.8.4.2 Fall-through：注释
在一个switch块内，每个语句组要么通过break, continue, return或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是OK的(典型的是用// fall through)。这个特殊的注释并不需要在最后一个语句组(一般是default)中出现。
3.8.4.3 default的情况要写出来
每个switch语句都包含一个default语句组，即使它什么代码也不包含。
3.8.5 注解(Annotations)
注解紧跟在文档块后面，应用于类、方法和构造函数，一个注解独占一行。这些换行不属于自动换行(第4.5节，自动换行)，因此缩进级别不变。
例外：单个的注解可以和签名的第一行出现在同一行。应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。参数和局部变量注解没有特定规则。
3.8.6 注释
3.8.6.1 块注释风格
块注释与其周围的代码在同一缩进级别。它们可以是/* ... */风格，也可以是// ...风格。对于多行的/* ... */注释，后续行必须从*开始， 并且与前一行的*对齐。以下示例注释都是OK的。注释不要封闭在由星号或其它字符绘制的框架里。
Tip：在写多行注释时，如果你希望在必要时能重新换行(即注释像段落风格一样)，那么使用/* ... */。
3.8.7 Modifiers
类和成员的modifiers如果存在，则按Java语言规范中推荐的顺序出现。
命名约定
4.1 对所有标识符都通用的规则
标识符只能使用ASCII字母和数字，因此每个有效的标识符名称都能匹配正则表达式\w+。在Google其它编程语言风格中使用的特殊前缀或后缀，如name_, mName, s_name和kName，在Java编程风格中都不再使用。
4.2 标识符类型的规则
4.2.1 包名
包名全部小写，连续的单词只是简单地连接起来，不使用下划线。
4.2.2 类名
类名都以UpperCamelCase风格编写。类名通常是名词或名词短语，接口名称有时可能是形容词或形容词短语。现在还没有特定的规则或行之有效的约定来命名注解类型。测试类的命名以它要测试的类的名称开始，以Test结束。例如，HashTest或HashIntegrationTest。
4.2.3 方法名
方法名都以lowerCamelCase风格编写。方法名通常是动词或动词短语。下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test<MethodUnderTest>_<state>，例如testPop_emptyStack。 并不存在唯一正确的方式来命名测试方法。
4.2.4 常量名
常量名命名模式为CONSTANT_CASE，全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？每个常量都是一个静态final字段，但不是所有静态final字段都是常量。在决定一个字段是否是一个常量时， 考虑它是否真的感觉像是一个常量。例如，如果任何一个该实例的观测状态是可变的，则它几乎肯定不会是一个常量。 只是永远不打算改变对象一般是不够的，它要真的一直不变才能将它示为常量。这些名字通常是名词或名词短语。
4.2.5 非常量字段名
非常量字段名以lowerCamelCase风格编写。这些名字通常是名词或名词短语。
4.2.6 参数名
参数名以lowerCamelCase风格编写。参数应该避免用单个字符命名。
4.2.7 局部变量名
局部变量名以lowerCamelCase风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。虽然缩写更宽松，但还是要避免用单字符进行命名，除了临时变量和循环变量。即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。
4.2.8 类型变量名
类型变量可用以下两种风格之一进行命名：单个的大写字母，后面可以跟一个数字(如：E, T, X, T2)。以类命名方式(5.2.2节)，后面加个大写的T(如：RequestT, FooBarT)。
4.3 驼峰式命名法(CamelCase)
驼峰式命名法分大驼峰式命名法(UpperCamelCase)和小驼峰式命名法(lowerCamelCase)。 有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如"IPv6"或"iOS")。Google指定了以下的转换方案。名字从散文形式(prose form)开始:
1.把短语转换为纯ASCII码，并且移除任何单引号。例如："Müller’s algorithm"将变成"Muellers algorithm"。
2.把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。
推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如"AdWords"将分割成"ad words")。 需要注意的是"iOS"并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。
3.现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：
每个单词的第一个字母都大写，来得到大驼峰式命名。
除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。
4.最后将所有的单词连接起来得到一个标识符。加星号处表示可以，但不推荐。
Note：在英语中，某些带有连字符的单词形式不唯一。例如："nonempty"和"non-empty"都是正确的，因此方法名checkNonempty和checkNonEmpty也都是正确的。
编程实践
5.1 @Override：能用则用
只要是合法的，就把@Override注解给用上。
5.2 捕获的异常：不能忽视
除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个AssertionError重新抛出。)如果它确实是不需要在catch块中做任何响应，需要做注释加以说明。
例外：在测试中，如果一个捕获的异常被命名为expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。
5.3 静态成员：使用类进行调用
使用类名调用静态的类成员，而不是具体某个对象或表达式。
5.4 Finalizers: 禁用
极少会去重载Object.finalize。
Tip：不要使用finalize。如果你非要使用它，请先仔细阅读和理解Effective Java 第7条款：“Avoid Finalizers”，然后不要使用它。
Javadoc
6.1 格式
6.1.1 一般形式
Javadoc块的基本格式如下所示：
或者是以下单行形式：
基本格式总是OK的。当整个Javadoc块能容纳于一行时(且没有Javadoc标记@XXX)，可以使用单行形式。
6.1.2 段落
空行(即，只包含最左侧星号的行)会出现在段落之间和Javadoc标记(@XXX)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签<p>，并且它和第一个单词间没有空格。
6.1.3 Javadoc标记
标准的Javadoc标记按以下顺序出现：@param, @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进4个空格。
6.2 摘要片段
每个类或成员的Javadoc以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以A {@code Foo} is a...或This method returns...开头, 它也不会是一个完整的祈使句，如Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。
Tip：一个常见的错误是把简单的Javadoc写成/** @return the customer ID */，这是不正确的。它应该写成/** Returns the customer ID. */。
6.3 哪里需要使用Javadoc
至少在每个public类及它的每个public和protected成员处使用Javadoc，以下是一些例外：
6.3.1 例外：不言自明的方法
对于简单明显的方法如getFoo，Javadoc是可选的(即，是可以不写的)。这种情况下除了写“Returns the foo”，确实也没有什么值得写了。单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。
Tip：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。
6.3.2 例外：重载
如果一个方法重载了超类中的方法，那么Javadoc并非必需的。
6.3.3 可选的Javadoc
对于包外不可见的类和方法，如有需要，也是要使用Javadoc的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成Javadoc，这样更统一更友好。


